#include "electrode.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <signal.h>
#include <time.h>
#include <assert.h>
#include <errno.h>
#include <sys/resource.h>
#include <asm-generic/posix_types.h>
#include <linux/if_link.h>
#include <stdarg.h>
#include <linux/limits.h>
#include <linux/bpf.h>
#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include <errno.h>

#define BPF_SYSFS_ROOT "/sys/fs/bpf"
// File generated by deploy.sh containing the MAC address
#define MAC_CONFIG_FILE "./mac_config.txt"
// "aa:bb:cc:dd:ee:ff" + NUL
#define MAC_ADDR_STR_LEN 18
#define BPF_OBJECT_FILE_PATH "./electrode.bpf.o"
// File listing interfaces to attach (one device name per line)
#define INTERFACE_CONFIG_FILE "./interface_config.txt"

struct bpf_program *tc_broadcast_prog;
struct bpf_object *obj;				  // libbpf object representing the loaded BPF ELF and attributes for load
__u32 xdp_flags = XDP_FLAGS_DRV_MODE; // XDP attach flags
int ifindex = -1;					  // single interface index loaded from config
char ifname[IF_NAMESIZE] = "eth1";	  // interface name loaded from config

static inline int bpf_map__update_elem(const struct bpf_map *map,
									   const void *key, size_t key_sz,
									   const void *value, size_t value_sz,
									   __u64 flags)
{
	if (!map || !key || !value)
		return -EINVAL;

	if (key_sz == 0 || value_sz == 0)
		return -EINVAL;

	int fd = bpf_map__fd(map);
	if (fd < 0)
		return fd;

	return bpf_map_update_elem(fd, key, value, flags);
}

static size_t load_mac_addresses(char macs[][MAC_ADDR_STR_LEN], size_t max_entries)
{
	FILE *mac_fp = fopen(MAC_CONFIG_FILE, "r");
	if (!mac_fp)
	{
		fprintf(stderr, "Error: failed to open MAC config file %s\n", MAC_CONFIG_FILE);
		exit(EXIT_FAILURE);
	}

	char line[256];
	size_t count = 0;

	while (count < max_entries && fgets(line, sizeof(line), mac_fp) != NULL)
	{
		if (line[0] == '\0' || line[0] == '#')
			continue;

		snprintf(macs[count], MAC_ADDR_STR_LEN, "%s", line);
		count++;
	}

	fclose(mac_fp);
	return count;
}

void load_if(void)
{
	ifindex = (int)if_nametoindex(ifname);
	if (ifindex == 0)
	{
		fprintf(stderr, "Error: interface '%s' not found\n", ifname);
		exit(EXIT_FAILURE);
	}
}

void load_object()
{
	obj = bpf_object__open_file(BPF_OBJECT_FILE_PATH, NULL);
	if (!obj)
	{
		fprintf(stderr, "Error: bpf_object__open failed\n");
		exit(EXIT_FAILURE);
	}

	int err = bpf_object__load(obj);
	if (err)
	{
		fprintf(stderr, "Error: bpf_object__load failed\n");
		bpf_object__close(obj);
		exit(EXIT_FAILURE);
	}
}

void populate_prog_array_map()
{
	struct bpf_map *xdp_progs_map = bpf_object__find_map_by_name(obj, "xdp_progs_map");
	if (!xdp_progs_map)
	{
		fprintf(stderr, "Error: failed to find xdp_progs_map map object\n");
		exit(EXIT_FAILURE);
	}

	struct bpf_program *fast_ACK_prog = bpf_object__find_program_by_name(obj, "fast_ACK");

	int prog_fd = bpf_program__fd(fast_ACK_prog);

	__u32 zero = (__u32)0;
	if (bpf_map__update_elem(xdp_progs_map, &zero, sizeof(zero), &prog_fd, sizeof(prog_fd), 0))
	{
		fprintf(stderr, "Error: failed to update xdp_progs_map for fast_ACK\n");
		exit(EXIT_FAILURE);
	}
}

void wait_for_termination()
{
	sigset_t set;
	int sig;

	sigfillset(&set);

	sigprocmask(SIG_BLOCK, &set, NULL);

	while (sigwait(&set, &sig) == 0)
		if (sig == SIGINT || sig == SIGTERM)
			break;
}

void attach_prog()
{
	if (ifindex < 0)
	{
		fprintf(stderr, "Error: interface index not initialized\n");
		exit(EXIT_FAILURE);
	}

	// Attach xdp_dispatcher to ifindex
	struct bpf_program *xdp_dispatcher_prog = bpf_object__find_program_by_name(obj, "xdp_dispatcher");
	if (bpf_set_link_xdp_fd(ifindex, bpf_program__fd(xdp_dispatcher_prog), xdp_flags) < 0)
	{
		fprintf(stderr, "Error: bpf_set_link_xdp_fd failed for interface %s (ifindex %d)\n", ifname, ifindex);
		exit(EXIT_FAILURE);
	}
	printf("xdp_dispatcher attached to interface %s (ifindex %d)\n", ifname, ifindex);
}

static void config_die(FILE *fp, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);

    if (fp)
        fclose(fp);
    exit(EXIT_FAILURE);
}

static void parse_replica_entry(FILE *fp, int idx, struct sockaddr_in *sa,
                                char macs[][MAC_ADDR_STR_LEN], size_t mac_count,
                                struct bpf_map *map_configure_map)
{
    char buff[255];
    char str[INET_ADDRSTRLEN];
    struct peer_config conf;

    if (fscanf(fp, "%255s", buff) != 1)
        config_die(fp, "Error: expected 'replica' token on line %d\n", idx + 2);
    if (strcmp(buff, "replica") != 0)
        config_die(fp, "Error: expected 'replica' keyword, got '%s' on line %d\n", buff, idx + 2);
    if (fscanf(fp, "%255s", buff) != 1)
        config_die(fp, "Error: missing address:port after 'replica' on line %d\n", idx + 2);

    char *ipv4 = strtok(buff, ":");
    assert(ipv4 != NULL);
    char *port = strtok(NULL, ":");

    if (inet_pton(AF_INET, ipv4, &(sa->sin_addr)) != 1)
        config_die(fp, "Error: invalid IPv4 address '%s' on line %d\n", ipv4, idx + 2);

    inet_ntop(AF_INET, &(sa->sin_addr), str, INET_ADDRSTRLEN);
    if (!port)
        config_die(fp, "Error: missing port in address on line %d\n", idx + 2);

    int port_num = atoi(port);
    if (port_num <= 0 || port_num > 65535)
        config_die(fp, "Error: invalid port '%s' on line %d\n", port, idx + 2);

    conf.port = htons((uint16_t)port_num);
    conf.addr = sa->sin_addr.s_addr;

    if (idx >= (int)mac_count)
        config_die(fp, "Error: MAC address for replica %d not found in %s\n", idx, MAC_CONFIG_FILE);

    if (sscanf(macs[idx], "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
               conf.eth, conf.eth + 1, conf.eth + 2,
               conf.eth + 3, conf.eth + 4, conf.eth + 5) != 6)
        config_die(fp, "Error: Invalid MAC address format '%s' for replica %d\n", macs[idx], idx);

    __u32 key = (__u32)idx;
    if (bpf_map__update_elem(map_configure_map, &key, sizeof(key), &conf, sizeof(conf), 0))
        config_die(fp, "Error: failed to update peer_config_map for replica %d\n", idx);
}

void read_config()
{
    struct bpf_map *map_configure_map = bpf_object__find_map_by_name(obj, "peer_config_map");
    if (!map_configure_map)
    {
        fprintf(stderr, "Error: bpf_object__find_map_by_name failed\n");
        exit(EXIT_FAILURE);
    }

    FILE *fp = fopen("../config.txt", "r");
    if (!fp)
        config_die(fp, "Error: failed to open config file ../config.txt\n");

    char buff[255];
    int f = 0;
    struct sockaddr_in sa = {0};
    char macs[REPLICA_MAX_NUM][MAC_ADDR_STR_LEN] = {{0}};
    size_t mac_count = load_mac_addresses(macs, REPLICA_MAX_NUM);

    if (fscanf(fp, "%s", buff) != 1)
        config_die(fp, "Error: failed to read quorum size marker from config file\n");
    if (strcmp(buff, "f") != 0)
        config_die(fp, "Error: expected 'f' token at start of config, got '%s'\n", buff);
    if (fscanf(fp, "%d", &f) != 1)
        config_die(fp, "Error: failed to read f value from config file\n");

    for (int i = 0; i < 2 * f + 1; ++i)
        parse_replica_entry(fp, i, &sa, macs, mac_count, map_configure_map);

    fclose(fp);
}

// Pin tc_broadcast program so TC can reference it by path
void pin_tc_broadcast()
{
	tc_broadcast_prog = bpf_object__find_program_by_name(obj, "tc_broadcast");
	int err = bpf_program__pin(tc_broadcast_prog, "/sys/fs/bpf/tc_broadcast");
	if (err)
	{
		fprintf(stderr, "Error: bpf_program__pin failed for tc_broadcast\n");
		exit(EXIT_FAILURE);
	}
}

int main(int argc, char *argv[])
{
	load_if();
	load_object();
	populate_prog_array_map();
	read_config();
	attach_prog();
	pin_tc_broadcast();
	bpf_object__pin_maps(obj, BPF_SYSFS_ROOT); // Pin all maps in bpffs so they can be shared/reused

	wait_for_termination();											   // Keep process alive and allow clean detach on signal
	bpf_set_link_xdp_fd(ifindex, -1, xdp_flags);					   // Detach XDP program by passing -1 as FD
	bpf_object__unpin_maps(obj, BPF_SYSFS_ROOT);					   // Unpin maps
	bpf_program__unpin(tc_broadcast_prog, "/sys/fs/bpf/tc_broadcast"); // Unpin tc_broadcast program
	bpf_object__close(obj);											   // close object
	printf("Safe exit.\n");
	return 0;
}